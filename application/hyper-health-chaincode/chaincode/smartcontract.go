package chaincode

import (
	"encoding/json"
	"fmt"
	"hash/fnv"
	"time"

	"github.com/shane-novit9/xacml"

	"github.com/hyperledger/fabric-contract-api-go/contractapi"
)

// SmartContract provides functions for managing an Asset
type SmartContract struct {
	contractapi.Contract
}

type Policy struct {
	PatientID string `json:"PatientID"`
	Xacml     string `json:"Xacml"`
}

type RecordRequest struct {
	ID                 string `json:"ID"`
	PatientKey         string `json:"PatientKey"`
	ProviderKey        string `json:"ProviderKey"`
	Response           string `json:"Response"`
	Request            string `json:"Request"`
	RequestingProvider string `json:"RequestingProvider"`
}

const (
	PolicyKeyPrefix   = "/users/policies/"
	RequestKeyPrefix  = "/users/requests/"
	ResponseKeyPrefix = "/users/responses/"
)

func hash(target string) uint32 {
	h := fnv.New32a()
	h.Write([]byte(target))
	return h.Sum32()
}

// Purely for testing purposes!
// Add an inital Policy to the ledger
func (s *SmartContract) InitLedger(ctx contractapi.TransactionContextInterface) error {
	patientID := "123456"

	var policy = `<?xml version="1.0" encoding="UTF-8"?>
	<Policy xmlns="urn:oasis:names:tc:xacml:3.0:core:schema:wd-17" 
			xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
			xsi:schemaLocation="urn:oasis:names:tc:xacml:3.0:core:schema:wd-17 http://docs.oasis-open.org/xacml/3.0/xacml-core-v3-schema-wd-17.xsd" 
			PolicyId="simple-policy" 
			Version="1.0" 
			RuleCombiningAlgId="urn:oasis:names:tc:xacml:3.0:rule-combining-algorithm:deny-overrides">
		<Description>Patient Policy</Description>
		<Target>
		  <AnyOf>
			<AllOf>
			  <Match MatchId="urn:oasis:names:tc:xacml:1.0:function:string-equal">
				<AttributeValue DataType="http://www.w3.org/2001/XMLSchema#string">
				  ^/record.txt</AttributeValue>
				<AttributeDesignator
				  MustBePresent="false"
				  Category="urn:oasis:names:tc:xacml:3.0:attribute-category:resource"
				  AttributeId="urn:oasis:names:tc:xacml:1.0:resource:resource-id" 
				  DataType="http://www.w3.org/2001/XMLSchema#string"/>
			  </Match>
			</AllOf>
		  </AnyOf>
		</Target>
		<Rule
		  RuleId="urn:oasis:names:tc:xacml:3.0:example:SimpleRule"
		  Effect="Permit">
		  <Description>
			  Deny record access 
		  </Description>
		  <Target>
			<AnyOf>
			  <AllOf>
				<Match
				  MatchId="urn:oasis:names:tc:xacml:1.0:function:string-equal">
				  <AttributeValue DataType="http://www.w3.org/2001/XMLSchema#string">
					Carl</AttributeValue>
				  <AttributeDesignator
					MustBePresent="false"
					Category="urn:oasis:names:tc:xacml:1.0:subject-category:access-subject"
					AttributeId="urn:oasis:names:tc:xacml:1.0:subject:subject-id"
					DataType="http://www.w3.org/2001/XMLSchema#string"/>
				</Match>
				<Match
				  MatchId="urn:oasis:names:tc:xacml:1.0:function:string-equal">
				  <AttributeValue DataType="http://www.w3.org/2001/XMLSchema#string">
					read</AttributeValue>
				  <AttributeDesignator
					MustBePresent="false"
					Category="urn:oasis:names:tc:xacml:1.0:attribute-category:action"
					AttributeId="urn:oasis:names:tc:xacml:1.0:action:action-id"
					DataType="http://www.w3.org/2001/XMLSchema#string"/>
				</Match>
			  </AllOf>
			</AnyOf>
		  </Target>
		</Rule>
	</Policy>`

	err := s.CreatePolicy(ctx, patientID, policy)
	if err != nil {
		return err
	}

	return nil
}

// CreatePolicy will be called when a patient initially signs into the system. Rather than taking in the patientID as a parameter,
// the function should generate an ID based on 'NIST SP 800-63B-4 ipd Digital Identity Guidelines' and return it to be stored in this
// Patient's PatientAccount for use in further operations.
func (s *SmartContract) CreatePolicy(ctx contractapi.TransactionContextInterface, patientID string, policy string) error {
	exists, err := s.PolicyExists(ctx, patientID)
	if err != nil {
		return err
	}
	if exists {
		return fmt.Errorf("policy for patient %v already exists, use updatepolicy to overwrite the current value", patientID)
	}

	policyObj := Policy{
		PatientID: PolicyKeyPrefix + patientID,
		Xacml:     policy,
	}

	policyJson, err := json.Marshal(policyObj)
	if err != nil {
		return err
	}

	return ctx.GetStub().PutState(policyObj.PatientID, []byte(policyJson))
}

// ReadPolicy should only be available to Patients and each Patient should only be able to read their own
// policy. This is done by using the ID generated by this SmartContract which would be inserted into this
// function by the web server. This should eliminating the potential for injection on the client-side.
func (s *SmartContract) ReadPolicy(ctx contractapi.TransactionContextInterface, id string) (*Policy, error) {
	policyJSON, err := ctx.GetStub().GetState(PolicyKeyPrefix + id)
	if err != nil {
		return nil, fmt.Errorf("failed to read from world state: %v", err)
	}
	if policyJSON == nil {
		return nil, fmt.Errorf("the asset %s does not exist", id)
	}

	var policy Policy
	err = json.Unmarshal(policyJSON, &policy)

	if err != nil {
		return nil, err
	}

	return &policy, nil
}

func (s *SmartContract) UpdatePolicy(ctx contractapi.TransactionContextInterface, PatientId, policy string) error {
	exists, err := s.PolicyExists(ctx, PatientId)
	if err != nil {
		return err
	}
	if !exists {
		return fmt.Errorf("the asset %s does not exist", PatientId)
	}

	policyObj := Policy{
		PatientID: PatientId,
		Xacml:     policy,
	}

	policyJSON, err := json.Marshal(policyObj)
	if err != nil {
		return err
	}

	return ctx.GetStub().PutState(PolicyKeyPrefix+PatientId, []byte(policyJSON))
}

func (s *SmartContract) RequestRecord(ctx contractapi.TransactionContextInterface, patientID, providerID, request string) (*RecordRequest, error) {
	policyJSON, error := ctx.GetStub().GetState(PolicyKeyPrefix + patientID)
	exists := policyJSON != nil
	if !exists {
		return nil, fmt.Errorf("Policy search returned - %v", exists)
	}
	if error != nil {
		return nil, error
	}

	var policy Policy
	error = json.Unmarshal(policyJSON, &policy)
	if error != nil {
		return nil, error
	}

	resp, err := xacml.PolicyDecisionPoint(policy.Xacml, request)
	if err != nil {
		return nil, err
	}

	Provider, err := ctx.GetClientIdentity().GetID()
	if err != nil {
		return nil, err
	}

	time := time.Now()
	requestID := fmt.Sprint(hash(policy.Xacml + request + resp + time.String()))

	patientCompositeAttributes := []string{
		RequestKeyPrefix,
		patientID + "/",
		providerID + "/",
		requestID,
	}
	providerCompositeAttributes := []string{
		ResponseKeyPrefix,
		providerID + "/",
		patientID + "/",
		requestID,
	}

	PatientFacingID, err := ctx.GetStub().CreateCompositeKey("string", patientCompositeAttributes)
	ProviderFacingID, err := ctx.GetStub().CreateCompositeKey("string", providerCompositeAttributes)

	fmt.Printf("Patient Key: %v", PatientFacingID)
	fmt.Printf("Provider Key: %v", ProviderFacingID)

	requestResponse := RecordRequest{
		ID:                 requestID,
		PatientKey:         PatientFacingID,
		ProviderKey:        ProviderFacingID,
		Response:           resp,
		Request:            request,
		RequestingProvider: Provider,
	}

	responseJSON, err := json.Marshal(requestResponse)
	if err != nil {
		return nil, err
	}

	// Add the Request to the ledger which can be searched for by the Patient whose Record was Requested
	err = ctx.GetStub().PutState(PatientFacingID, responseJSON)
	if err != nil {
		return nil, err
	}

	// Add the request to the ledger which can be searched for by Providers participating in the channel
	return &requestResponse, ctx.GetStub().PutState(ProviderFacingID, responseJSON)
}

func (s *SmartContract) PolicyExists(ctx contractapi.TransactionContextInterface, PatientId string) (bool, error) {
	policyJSON, err := ctx.GetStub().GetState(PolicyKeyPrefix + PatientId)
	if err != nil {
		return false, fmt.Errorf("failed to read from world state: %v", err)
	}

	return policyJSON != nil, nil
}

func (s *SmartContract) ReadResponce(ctx contractapi.TransactionContextInterface, id string) (*RecordRequest, error) {
	responceJSON, err := ctx.GetStub().GetState(id)
	if err != nil {
		return nil, fmt.Errorf("failed to read from world state: %v", err)
	}
	if responceJSON == nil {
		return nil, fmt.Errorf("the asset %s does not exist", id)
	}

	var response RecordRequest
	err = json.Unmarshal(responceJSON, &response)

	if err != nil {
		return nil, err
	}

	return &response, nil
}

// *Search by creating a composite key and splitting it to isolate certain IDs*

// Search for all requests made for this patient's Medical Records (Shouldn't allow other patients or providers to do this)
func (s *SmartContract) GetAllPatientRequests(ctx contractapi.TransactionContextInterface, id string) ([]*RecordRequest, error) {
	patientCompositeAttributes := []string{
		RequestKeyPrefix,
		id + "/",
	}

	requestIterator, err := ctx.GetStub().GetStateByPartialCompositeKey("string", patientCompositeAttributes)
	if err != nil {
		return nil, err
	}

	var requests []*RecordRequest
	for requestIterator.HasNext() {
		queryResponse, err := requestIterator.Next()
		if err != nil {
			return nil, err
		}

		var request RecordRequest
		err = json.Unmarshal(queryResponse.Value, &request)
		if err != nil {
			return nil, err
		}
		requests = append(requests, &request)
	}

	return requests, nil
}

// Search for all requests made by a certain provider (Any provider can perform this action)
func (s *SmartContract) GetAllProviderRequests(ctx contractapi.TransactionContextInterface, id string) ([]*RecordRequest, error) {
	return nil, nil
}
